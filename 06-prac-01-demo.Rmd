---
title: "06-prac-01"
author: "yiyan"
date: "2023-11-14"
output: html_document
---
WEEK6
For any given London Borough, are the Blue Plaques within that borough distributed randomly or do they exhibit some kind of dispersed or clustered pattern?

# packages
```{r}
library(spatstat) #spatstat is a package for analyzing spatial point pattern data
library(here)
library(sp)
library(tmap)
library(sf)
library(tidyverse)
library(geojson)
library(geojsonio)
library(tmaptools)
library(rgeos)
library(maptools)
```

# read data
```{r}
LondonBorough <- st_read("wk1/london_borough/data/statistical-gis-boundaries-london/ESRI/London_Borough_Excluding_MHW.shp")%>% 
  st_transform(., crs = 27700)

# get the location of all Blue Plaques in the City
BluePlaques <- st_read("https://s3.eu-west-2.amazonaws.com/openplaques/open-plaques-london-2018-04-08.geojson") %>% 
  st_transform(., crs = 27700)
```

```{r}
# read in csv and make into spatial data
Airbnb <- read_csv("wk5/data/listings.csv") %>% 
  st_as_sf(., coords = c("longitude","latitude"), crs = 4326) %>% 
  st_transform(.,27700) %>% 
  filter(room_type == 'Entire home/apt'& availability_365 =='365')
```

# pull out London
```{r}
library(stringr)
BoroughMap <- LondonBorough %>% 
  dplyr::filter(str_detect(GSS_CODE, "E09")) %>% 
  st_transform(., crs = 27700)

qtm(BoroughMap)
```
#summary
```{r}
summary(BoroughMap)
summary(BluePlaques)
```

```{r}
# plot the blue plaques
tmap_mode("plot")
tm_shape(BoroughMap) +
  tm_polygons(col=NA, alpha = 0.5) +
  tm_fill() +
  tm_shape(BluePlaques) +
  tm_dots(col = "blue", size = 0.02)
```
# data cleaning
```{r}
BluePlaques <- distinct(BluePlaques)
```

# spatial subsetting
```{r}
BluePlaquesSub <- BluePlaques[BoroughMap, ,]#default is intersect
#[BoroughMap, , op = st_within]

# st_overlaps, st_touches, st_contains, st_disjoint, st_intersects, st_within

#check to see that they've been removed
tmap_mode("plot")
tm_shape(BoroughMap) +
  tm_polygons(col=NA, alpha = 0.5) +
  tm_fill() +
  tm_shape(BluePlaquesSub) +
  tm_dots(col = "blue", size = 0.02)
```

use the function which will have the indices of where they intersect

```{r}
# select by location
intersect_indices <- st_intersects(BoroughMap, BluePlaques,sparse = FALSE)
```

# spatial clipping
x, st_difference(x,y),st_difference(y,x),st_union(x,y),st_intersection(x,y),st_sym_difference(x,y)

# read osm & airbnb data
```{r}
OSM <- st_read("wk5/data/greater-london-latest-free.shp/gis_osm_pois_free_1.shp") %>% 
  st_transform(.,27700) %>% 
  # select hotel only
  dplyr::filter(fclass == 'hotel')
```

# spatial joining
```{r}
join_example <- st_join(OSM,LondonBorough)
NROW(join_example)
```

## function for join
```{r}
Joinfun <- function(x,y){
  
  output <- x %>% 
    st_join(LondonBorough,.) %>%
    add_count(GSS_CODE, name="hotels_in_borough")
  
  return(output)
}
```

```{r}
# use the function for hotels
Hotels <- Joinfun(OSM, Londonborough)

# then for airbnb
Airbnb <- Joinfun(Airbnb, Londonborough)
 
Hotels <- Hotels %>%
  #at the moment each hotel is a row for the borough
  #we just one one row that has number of airbnbs
  group_by(., GSS_CODE, NAME)%>%
  summarise(`Accomodation count` = unique(hotels_in_borough))

Airbnb <- Airbnb %>%
  group_by(., GSS_CODE, NAME)%>%
  summarise(`Accomodation count` = unique(hotels_in_borough))
```
Airbnb sf object = airbnbs per borough
Hotels sf object = hotels per borough

join two sf objects together: st_join
st_join uses st_intersects() by default
```{r}
all_accomodation <- st_join(Hotels, Airbnb,join = st_equals)

head(all_accomodation)
```

- Select points or polygons in a polygon = Selecting data by location = spatial sub-setting

- Determine where datasets overlap (or touch, or donâ€™t overlap) and extract those parts = spatial clipping

- Join two spatial datasets together = spatial joining, which can use spatial subsetting functions as the default is st_intersects(). This function joins spatial data.

- Selecting data by attributes = filtering or selecting rows / columns with dplyr
```{r}
```

```{r}
```



